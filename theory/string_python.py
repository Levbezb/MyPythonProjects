name = input()      #команда input() считывает данные с клавиатуры, то есть со строки ввода
                    #следует учесть, что эта команда считывает строку текста, а не число
print("My name is ", name)      #команда print() выводит данные в компилятор

print('1', '2', '3', sep='+')     # также, чтобы вывести данные в компилятор, можно использовать необязательные параметры
                                  # sep='символ', этот параметр заполняет пробел, который был вызван наличием нескольких аргументов
                                  # (кавычек в принт) символом, который мы можем указать

print('1', '2', '3', end='-')     # и необязательный параметр end='символ' , он, заменяет перенос строки на символ, который мы можем указать
print('1', '2', '3', end='-')
                                 
                                  # изначално эти параметры выглядят так:
                                  # print('1', '2', '3', sep=' ')
                                  # print('1', '2', '3', end='\n')

print('f', 'f', 'f', sep='')      # также можно убрать пробелы вообще


string1 = '123456789'
length = len(string1)             # Чтобы узнать длину строки, можно воспользоваться функцией len()

c = 10
string2 = str(c)                  # Как мы уже знаем, можно преобразовать число в строку с помощью функции str()


string3 = '1' + string1 + string2 + '4'    # В питоне есть такая вещь, как конкатенация строк или сложение, склеивание
string4 = '-' * 25                         # В Python также можно умножать строку на число.
                                           # Такой оператор повторяет строку указанное количество раз
string5 = '''Привет.                       
Как дела?
Пока.'''                                   # Также можно воспользоваться тройными кавычками, чтобы записать текст на нескольких строках

string6 = 'qwertyuiop'
if 'w' in string6:                         # В Python есть специальный оператор in,
    print('yes')                           # который позволяет проверить, что одна строка находится внутри другой.


s = 'abcdef'                        # С помощью такой конструкции можно обраттиться к конкретному символу строки, для этого импользуются
first = s[0]                        # квадратные скобки [] и индекс(номер) нужного символа, индексация начинается с 0
second = s[1]                       # Индекс может быть отрицательным, в таком случае индекс последнего символа будет равен -1, 
                                    # предпоследнего -2, и так далее
last = s[-1]                        # или last = s[5]


s = 'abcdef'                        # С помощью такой коснтрукции можно вывести все символы s,
for c in s:                         # в отличие от for i in range() такой цикл работает без чисел, в каждом витке c принимает значения s,
    print(c)                        # в 1 витке это a, во втором b, в третьем c

                # Обратите внимание на обозначение переменных цикла. В первом цикле мы используем имя i, что соответствует
                # стандартной идеологии наименования переменных цикла. 
                # Во втором цикле, мы назвали переменную буквой c – первая буква слова char (символ).

s = 'abcdefgh'                      # Пример использования срезов в питоне
c = s[2:6]                          # С помощью среза мы можем получить несколько символов исходной строки, 
print(c)                            # создав диапазон индексов разделенных двоеточием s[x:y]
                                    # При построении среза [x:y] первое число x, это место где начинается срез(включительно),
                                    # а второе y, место где заканчивается(не включительно)
c = s[2:]
print(c)                            # в срезе можно опустить 2 параметр s[x:], будет выведена строка, индексы которой начинаются с x, и 
                                    # закачиваются в конце строки, аналогично для s[:y], от 0 до y не включительно
                                    # срез s[:] возвращает исходную строку
                                    # срез можно использовать с отрицательными индексами, при этом первый параметр должен быть меньше второго
                                    # либо его не должно быть
                # Удалить из строки последний символ можно при помощи среза s[:-1]

c = s[1:7:2]                        # в срезе можно ввести доп параметр, это шаг
print(s)                            

print(s[::-1])                      # если указать -1 в качестве шага, то символы будут выводиться в обратном порядке

s = s[:4] + 'X' + s[5:]             # с помощью срезов можно поменять содержимое строки, стоит учесть, что такой код не сработает:
                                    # s[4] = 'X' , потому что строки в пайтон считаются неизменяемыми
                                    
                # срезы напоминают синтаксис функции range()
                # если 1 параметр будет больше второго, то срез создаст пустую строку


s = 'SAy mY NamE'
print(s.capitalize())               # Метод capitalize() возвращает копию строки, в которой первый символ заглавный, а остальные не заглавные
# Say my name                         Символы не являющиеся буквами алфавита остаются неизменными

print(s.swapcase())                 # Метод swapcase() возвращает копию строки, в которой Заглавные символы становятся маленькими, а 
# saY My nAMe                         маленькие заглавными, по сути меняет регистр наоборот

print(s.title())                    # Метод title() делает так, что первый символ каждого слова становится Заглавным
# Say My Name                         Этот метод использует довольно простой алгоритм: он не пытается различить 
                                    # важные и неважные слова и не обрабатывает аббревиатуры и апострофы

print(s.lower())                    # Этот метод преобразовывает все символы в нижний регистр
# say my name

print(s.upper())                    # А этот все в верхний регистр
# SAY MY NAME
                                    # важная деталь, что методы строк не преобразуют исходную, а создают новую



            # к следующим методам можно ввести доп условия <start> и <end>, в данном случае поиск будет происходить с индекса старт
            # по индекс end не включительно

s = 'aanhsaaaanhaaa'
print(s.count('aa'))                # метод count() считает сколько непересекающихся подстрок есть в исходной строке
# 4                                

print(s.startswith('aa'))           # метод startswith() проверят начинается ли строка с символа указанного в скобках, если да, то выводит True
# True                                в противном случае False

print(s.endswith('aa'))             # то же самое, что startswith(), только проверяется конец строки
# True

print(s.find('hs'))                 # метод find() ищет индекс первого вхождения подстроки в строке
# 3                                   если данной подстроки нет, то выводит -1

print(s.rfind('hs'))                # то же самое, что и find(), только ищет с конца строки
# 3

print(s.index('hs'))                # то же самое, что find() и rfind(), но если такой подстроки нет, то выводит ошибку
# 3                                   также и с rindex()

print(s.strip())                    # метод strip() возвращает копию строки, и удаляет все пробелы с начала и в конце строки
# aanhsaaaanhaaa

print(s.lstrip(), s.rstrip())       # метод lstrip() удаляет все пробелы с начала строки, а метод rstrip() все пробелы в конце строки
        # методы strip  могут применять необязательный аргумент <chars>, которое будет определять символы для удаления


print(s.replace('a', 'b'))          # метод replace(<old>, <new>) заменяет все символы old на new, можно ввести 3 доп значение, которое будет
# bbnhsbbbbnhbbb                      определять количество замен



s = 'abc123'
print(s.isalnum())                  # метод isalnum() определяет состоит ли строка из букв и чисел (буквенночисловых символов), если да то True
# True                                если нет, то False

print(s.isalpha())                  # метод isalpha() проверяет состоит ли строка из буквенных символов
# False

print(s.isdigit())                  # метож isdigit() проверяет состоит ли строка из чисел
# False

print(s.islower())                  # метод islower() проверяет, находятся ли все символы в нижнем регистре (строчные)
# True                              этот метод игнорирует все небуквенные  символы, поэтому если в строке не будет букв, то метод выведет False

print(s.isupper())                  # то же самое, что islower(), только для заглавных букв
# False

print(s.isspace())                  # метод isspace() проверяет, состоит ли строка только из пробелов, если да, возвращает True
# False                               False в противном случае, для пустой строки возвращает False



year = 2009
print('My name is Lev, I was born in {0}'.format(year))      # Метод format() помогает вносить изменения в строку, для этого посреди строки
                                            # нужно поставить фигурные скобки {} и после, в аргументах метода написать то, что мы хотим вставить
                                            # этих аргументов может быть много, поэтому в фигурных скобках можно написать числа: 0, 1, 2, ....
                                            # они будут отвечать, за то, что вставить в скобку

# Метод format() можно использовать эффективнее, для этого есть f-строки
print(f'1 + 2 = {1+2}')
# или
print(f'My name is Lev, I was born in{year}')   # как мы видим, с такой конструкцией можно  обращаться сразу к пременным или выражениям, без
                                            # употребления лишних строк и символов
'''
Ключевые моменты:
Для валюты:

:.2f - 2 знака после запятой

:, - разделитель тысяч

:,.2f - вместе: разделитель тысяч + 2 знака после запятой

Для процентов:

:% - автоматическое умножение на 100 и добавление знака %

:.1% - 1 знак после запятой в процентах

:+.2% - с отображением знака и 2 знаками после запятой

Эти методы делают вывод финансовых данных чистым и профессиональным!
''' 
value = 10000000
print(f'value = {value:,}')
# value = 10,000,000

print(ord('A'))                     # Функция ord() определяет код некоторого символа в таблице unicode
# 65                                  При чем если ввести больше 1 символа произойдет ошибка

print(chr(66))                      # Функция chr() определяет символ некоторого кода в таблице unicode
# B


print('a'.ljust(3))     # Строковый метод ljust() выравнивает текст по ширине, добавляя пробелы в конец текста.
print('ab'.ljust(3))


print('a'.rjust(3))     # Строковый метод rjust() выравнивает текст по ширине, добавляя пробелы в начало текста.
print('ab'.rjust(3))

# Исходная строка не обрезается, даже если в ней больше символов, чем нужно.
